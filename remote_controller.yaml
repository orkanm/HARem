substitutions:
  name: "ha-remote"
  friendly_name: "HA Remote Controller"
  fw_version: "v0.1"

esphome:
  name: harem
  friendly_name: HARem
  on_boot:
    priority: 600
    then:
      - script.execute: idle_timer

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: "7knRB3/EL4Fq8Foul7Yhv+pcABzyLXHSQxa9bTzzQqg="

ota:
  - platform: esphome
    password: "ad2825446c99da7cb65d49d3f691d24e"

wifi:
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password

    - ssid: !secret 2_wifi_ssid
      password: !secret 2_wifi_password

    - ssid: !secret 3_wifi_ssid
      password: !secret 3_wifi_password
    # Set a low power save mode to speed up the connection when waking up
  power_save_mode: LIGHT
  
  # Callback when Wi-Fi disconnects
  on_disconnect:
    - logger.log: "Wi-Fi disconnected!"
    - delay: 180s   # wait 3 minutes
    - if:
        condition:
          wifi.connected:
        then:
          - logger.log: "Wi-Fi reconnected within 3 minutes."
        else:
          - logger.log: "Wi-Fi still down, rebooting..."



  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Harem Fallback Hotspot"
    password: "S6OlfI3QTLQU"

captive_portal:

# Colors
color:
  - id: my_color_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_color_black
    red: 0%
    green: 0%
    blue: 0%

# I2C Configuration for OLED
i2c:
  sda: GPIO5
  scl: GPIO6
  scan: true
  id: bus_a

# Font configuration
font:
  - file: "gfonts://Roboto"
    id: font_main
    size: 14
  - file: "gfonts://Material Icons"
    id: font_icon
    size: 24
    glyphs:
      - "\U0000E0F0" # lightbulb (was mdi-lightbulb-on)
      - "\U0000E8AC" # power_settings_new (was mdi-power-plug? using generic power for now)
      - "\U0000E335" # power_off (was mdi-lightbulb-off? using close/off)
      - "\U0000E02C" # movie
      - "\U0000E63C" # power (plug)
  - file: "gfonts://Roboto"
    id: font_header
    size: 12
  - file: "gfonts://Roboto"
    id: font_small
    size: 10



# Globals to track state
globals:
  - id: is_awake
    type: bool
    restore_value: no
    initial_value: 'true'

# Import Home Assistant Entities
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO7
      mode: INPUT_PULLUP
      inverted: true
    name: "Encoder Button"
    id: encoder_button
    on_click:
      - min_length: 10ms
        max_length: 300ms
        then:
          - if:
              condition:
                lambda: 'return id(is_awake);'
              then:
                - script.execute: idle_timer
                - logger.log:
                    format: "Short Click Detected!"
                    level: INFO
                - homeassistant.event:
                    event: esphome.remote_action
                    data:
                      action: click
              else:
                - script.execute: idle_timer
                - logger.log: "Waking up from sleep"
      - min_length: 301ms
        max_length: 10s
        then:
          - logger.log:
              format: "Long Click Detected!"
              level: INFO
          - homeassistant.event:
              event: esphome.remote_action
              data:
                action: back

  # Status sensors removed - Managed by Home Assistant text
    
text_sensor:
  - platform: homeassistant
    id: remote_line_1
    entity_id: input_text.harem_line_1
  - platform: homeassistant
    id: remote_line_2
    entity_id: input_text.harem_line_2
  - platform: homeassistant
    id: remote_line_3
    entity_id: input_text.harem_line_3
  - platform: homeassistant
    id: remote_line_4
    entity_id: input_text.harem_line_4
  - platform: homeassistant
    id: remote_line_5
    entity_id: input_text.harem_line_5

  - platform: homeassistant
    id: remote_line_3_status
    entity_id: input_text.harem_line_3_status
  - platform: homeassistant
    id: remote_overlay
    entity_id: input_text.harem_overlay

sensor:
  - platform: rotary_encoder
    id: encoder
    pin_a:
      number: GPIO8
      mode: INPUT_PULLUP
    pin_b:
      number: GPIO9
      mode: INPUT_PULLUP
    resolution: 1
    on_clockwise:
      - script.execute: idle_timer
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: next
      - component.update: my_display
    on_anticlockwise:
      - script.execute: idle_timer
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: prev
      - component.update: my_display

  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_sensor
    update_interval: 60s

display:
  - platform: ssd1306_i2c
    model: "SH1106 128x64"
    address: 0x3C
    id: my_display
    i2c_id: bus_a
    update_interval: 0.1s
    lambda: |-
      // Draw Interface
      
      // 0. CHECK OVERLAY (Feedback Screen)
      if (id(remote_overlay).has_state() && id(remote_overlay).state != "") {
         // Clear screen
         it.fill(id(my_color_black));
         
         // Draw Box
         it.filled_rectangle(0, 0, 128, 64, id(my_color_black));
         
         // Draw Text Centered
         it.print(64, 25, id(font_header), TextAlign::TOP_CENTER, id(remote_overlay).state.c_str());
         
         // Draw spinner/dots? (Optional, let's keep it simple first)
         return; // Skip drawing the rest
      }

      // Draw Interface - 5 Lines
      
      // Line 1 (Index - 2) - y=6 (Safe from Top Bezel)
      if (id(remote_line_1).has_state()) {
        it.printf(64, 6, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_1).state.c_str());
      }
      
      // Line 2 (Index - 1) - y=17
      if (id(remote_line_2).has_state()) {
        it.printf(64, 17, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_2).state.c_str());
      }

      // Line 3 (Selected) - Split Layout: Name (Scrolls) + Status (Fixed)
      if (id(remote_line_3).state != "") {
        int x1, y1, width, height;
        std::string status_text = id(remote_line_3_status).state;
        int status_width = 0;
        
        // 1. Calculate Status Width
        if (status_text != "") {
           it.get_text_bounds(0, 0, status_text.c_str(), id(font_small), TextAlign::TOP_LEFT, &x1, &y1, &status_width, &height);
           status_width += 4; // Add padding
        }

        int max_name_width = 128 - status_width;
        
        // 2. Draw Name (Scrolling logic using max_name_width)
        std::string name_text = id(remote_line_3).state;
        int name_width = 0;
        it.get_text_bounds(0, 0, name_text.c_str(), id(font_header), TextAlign::TOP_LEFT, &x1, &y1, &name_width, &height);
        
        if (name_width <= max_name_width) {
             // Fits in available space - Center it
             it.print(max_name_width / 2, 28, id(font_header), TextAlign::TOP_CENTER, name_text.c_str());
        } else {
             // Too long - Scroll it
             // Let's force it to be 0 if it fits, else calculate.
             int limit = name_width - max_name_width + 30; // 30px pause
             int step = (millis() / 50) % limit;
             int x_offset = (step > (name_width - max_name_width)) ? (name_width - max_name_width) : step;
             
             it.print(0 - x_offset, 28, id(font_header), TextAlign::TOP_LEFT, name_text.c_str());
        }

        // 3. Draw Status (Fixed Right)
        if (status_text != "") {
           // Clear background for status
           it.filled_rectangle(128 - status_width, 28, status_width, 14, id(my_color_black));
           it.print(128, 29, id(font_small), TextAlign::TOP_RIGHT, status_text.c_str());
        }
      } else {
        if (millis() < 3000) {
          // Splash Screen (First 3.0s)
          it.print(64, 0, id(font_header), TextAlign::TOP_CENTER, "HARem");
          it.print(64, 25, id(font_small), TextAlign::TOP_CENTER, "HomeAssistant Remote");
          it.print(64, 40, id(font_small), TextAlign::TOP_CENTER, "Remote controller");
        } else {
          // Waiting Screen (After 3.0s)
          it.print(64, 20, id(font_header), TextAlign::TOP_CENTER, "Waiting...");
          it.print(64, 50, id(font_small), TextAlign::TOP_CENTER, "${fw_version}");
        }
      }

      // Line 4 (Index + 1) - y=41
      if (id(remote_line_4).has_state()) {
        it.printf(64, 41, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_4).state.c_str());
      }

      // Line 5 (Index + 2) - y=52 (Safe from Bottom Bezel)
      if (id(remote_line_5).has_state()) {
        it.printf(64, 52, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_5).state.c_str());
      }



# Script removed - Logic moved to Home Assistant

script:
  - id: idle_timer
    mode: restart
    then:
      - lambda: 'id(my_display).turn_on(); id(is_awake) = true;'
      - delay: 60s
      - lambda: 'id(my_display).turn_off(); id(is_awake) = false;'
