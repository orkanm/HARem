substitutions:
  name: "ha-remote"
  friendly_name: "HA Remote Controller"
  fw_version: "v0.2"

esphome:
  name: harem
  friendly_name: HARem
  on_boot:
    priority: 600
    then:
      - script.execute: idle_timer
      - lambda: 'id(my_display).set_contrast(id(screen_brightness) / 100.0);'

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: !secret harem_api_key

ota:
  - platform: esphome
    password: !secret harem_ota_password

wifi:
  id: wifi_component
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password

    - ssid: !secret 2_wifi_ssid
      password: !secret 2_wifi_password

    - ssid: !secret 3_wifi_ssid
      password: !secret 3_wifi_password
    # Set a low power save mode to speed up the connection when waking up
  power_save_mode: LIGHT
  
  # Callback when Wi-Fi disconnects
  on_disconnect:
    - logger.log: "Wi-Fi disconnected!"
    - delay: 180s   # wait 3 minutes
    - if:
        condition:
          wifi.connected:
        then:
          - logger.log: "Wi-Fi reconnected within 3 minutes."
        else:
          - logger.log: "Wi-Fi still down, rebooting..."



  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Harem Fallback Hotspot"
    password: !secret harem_ap_password

captive_portal:

# Colors
color:
  - id: my_color_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_color_black
    red: 0%
    green: 0%
    blue: 0%

# I2C Configuration for OLED
i2c:
  sda: GPIO5
  scl: GPIO6
  scan: true
  id: bus_a

# Font configuration
font:
  - file: "gfonts://Roboto"
    id: font_main
    size: 14
  - file: "gfonts://Material Icons"
    id: font_icon
    size: 24
    glyphs:
      - "\U0000E0F0" # lightbulb (was mdi-lightbulb-on)
      - "\U0000E8AC" # power_settings_new (was mdi-power-plug? using generic power for now)
      - "\U0000E335" # power_off (was mdi-lightbulb-off? using close/off)
      - "\U0000E02C" # movie
      - "\U0000E63C" # power (plug)
  - file: "gfonts://Roboto"
    id: font_header
    size: 12
  - file: "gfonts://Roboto"
    id: font_small
    size: 10
  - file: "gfonts://Roboto"
    id: font_count
    size: 32



# Globals to track state
globals:
  - id: is_awake
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: standby_duration_v2
    type: int
    restore_value: yes
    initial_value: '60'
  - id: screen_brightness
    type: int
    restore_value: yes
    initial_value: '100'
  - id: settings_mode
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: settings_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: edit_mode
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: press_time
    type: uint32_t
    initial_value: '0'
  - id: processed_settings_hold
    type: bool
    initial_value: 'false'
  - id: battery_percent
    type: float
    initial_value: '100.0'
  - id: sleep_timeout_v2
    type: int
    restore_value: yes
    initial_value: '60'
  - id: sleep_countdown
    type: int
    initial_value: '-1'

# Import Home Assistant Entities
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      allow_other_uses: true
      inverted: true
    filters:
      - delayed_off: 2ms
    name: "Encoder Button"
    id: encoder_button
    on_press:
      - lambda: |-
          id(press_time) = millis();
          id(processed_settings_hold) = false;
      - script.execute: handle_settings_hold
    on_release:
      - script.stop: handle_settings_hold
      - lambda: |-
          if (id(processed_settings_hold)) return;
          
          uint32_t duration = millis() - id(press_time);
          if (duration < 10) return; // Debounce
          
          if (duration < 800) {
            // SHORT CLICK
            if (id(settings_mode)) {
               id(idle_timer)->execute();
               if (id(settings_index) == 5) {
                 ESP_LOGD("main", "Settings Exit item clicked");
                 id(settings_mode) = false;
                 id(edit_mode) = false;
               } else if (id(settings_index) < 3) {
                 id(edit_mode) = !id(edit_mode);
               }
            } else {
               if (id(is_awake)) {
                 id(send_click_event)->execute();
               } else {
                 id(idle_timer)->execute();
               }
            }
          } else if (duration >= 800 && duration < 3500) {
            // BACK ACTION
            if (id(settings_mode)) {
               ESP_LOGD("main", "Exiting Settings via 1s hold");
               id(settings_mode) = false;
               id(edit_mode) = false;
            } else {
               id(send_back_event)->execute();
            }
          }


  # Status sensors removed - Managed by Home Assistant text
    
text_sensor:
  - platform: homeassistant
    id: remote_line_1
    entity_id: input_text.harem_line_1
  - platform: homeassistant
    id: remote_line_2
    entity_id: input_text.harem_line_2
  - platform: homeassistant
    id: remote_line_3
    entity_id: input_text.harem_line_3
  - platform: homeassistant
    id: remote_line_4
    entity_id: input_text.harem_line_4
  - platform: homeassistant
    id: remote_line_5
    entity_id: input_text.harem_line_5

  - platform: homeassistant
    id: remote_line_3_status
    entity_id: input_text.harem_line_3_status
  - platform: homeassistant
    id: remote_overlay
    entity_id: input_text.harem_overlay

  - platform: wifi_info
    ip_address:
      id: wifi_ip
    ssid:
      id: wifi_ssid

sensor:
  - platform: rotary_encoder
    id: encoder
    pin_a:
      number: GPIO8
      mode: INPUT_PULLUP
    pin_b:
      number: GPIO9
      mode: INPUT_PULLUP
    resolution: 1
    on_clockwise:
      - script.execute: idle_timer
      - if:
          condition: 
            lambda: 'return id(settings_mode);'
          then:
            - if:
                condition:
                  lambda: 'return id(edit_mode);'
                then:
                  # Adjust Value (+)
                   - lambda: |-
                       bool changed = false;
                       if (id(settings_index) == 0) { // Brightness
                          if (id(screen_brightness) < 100) {
                              id(screen_brightness) += 10;
                              id(my_display).set_contrast(id(screen_brightness) / 100.0);
                              changed = true;
                          }
                       } else if (id(settings_index) == 1) { // Standby
                          if (id(standby_duration_v2) < 300) {
                              id(standby_duration_v2) += 10;
                              changed = true;
                          }
                       } else if (id(settings_index) == 2) { // Sleep
                          if (id(sleep_timeout_v2) < 120) {
                              id(sleep_timeout_v2) += 10;
                              changed = true;
                          }
                       }
                       if (changed) id(my_display).update();
                else:
                  # Move Down (Wrapped)
                  - lambda: |-
                      // 0:Bright, 1:Standby, 2:Sleep, 3:WiFi, 4:IP, 5:Exit
                      id(settings_index)++;
                      if (id(settings_index) > 5) id(settings_index) = 0;
                      id(my_display).update();
          else:
            - homeassistant.event:
                event: esphome.remote_action
                data:
                  action: next
            # Removed unconditional update to prevent lag during rapid rotation

    on_anticlockwise:
      - script.execute: idle_timer
      - if:
          condition: 
            lambda: 'return id(settings_mode);'
          then:
             - if:
                condition:
                  lambda: 'return id(edit_mode);'
                then:
                  # Adjust Value (-)
                   - lambda: |-
                       bool changed = false;
                       if (id(settings_index) == 0) { // Brightness
                          if (id(screen_brightness) > 10) {
                              id(screen_brightness) -= 10;
                              id(my_display).set_contrast(id(screen_brightness) / 100.0);
                              changed = true;
                          }
                       } else if (id(settings_index) == 1) { // Standby
                          if (id(standby_duration_v2) > 10) {
                              id(standby_duration_v2) -= 10;
                              changed = true;
                          }
                       } else if (id(settings_index) == 2) { // Sleep
                          if (id(sleep_timeout_v2) > 10) {
                              id(sleep_timeout_v2) -= 10;
                              changed = true;
                          }
                       }
                       if (changed) id(my_display).update();
                else:
                  # Move Up (Wrapped)
                  - lambda: |-
                      if (id(settings_index) == 0) {
                          id(settings_index) = 5;
                      } else {
                          id(settings_index)--;
                      }
                      id(my_display).update();
          else:
            - homeassistant.event:
                event: esphome.remote_action
                data:
                  action: prev
            # Removed unconditional update

  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_sensor
    update_interval: 60s

  - platform: adc
    pin: GPIO0
    name: "Battery Voltage"
    id: battery_voltage_adc
    update_interval: 60s
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      - multiply: 2.0 
    on_value:
      then:
        - lambda: |-
            id(battery_percent) = (x - 3.2) / (4.2 - 3.2) * 100.0;
            if (id(battery_percent) > 100) id(battery_percent) = 100;
            if (id(battery_percent) < 0) id(battery_percent) = 0;
            id(my_display).update();

deep_sleep:
  id: sleep_module
  # Default sleep_duration is infinite (wake by pin)
  sleep_duration: 1d # Sleep for 1 day if not woken by pin
  wakeup_pin:
    number: GPIO4
    inverted: true
    mode: INPUT_PULLUP
    allow_other_uses: true




display:
  - platform: ssd1306_i2c
    model: "SH1106 128x64"
    address: 0x3C
    id: my_display
    i2c_id: bus_a
    update_interval: 0.1s
    lambda: |-
      // Draw Interface
      
      // 00B. CHECK FOR SLEEP COUNTDOWN
      if (id(sleep_countdown) > 0) {
        it.fill(id(my_color_black));
        it.printf(64, 32, id(font_count), TextAlign::CENTER, "%d", id(sleep_countdown));
        return;
      }

      // 00. CHECK FOR HOTSPOT MODE (WiFi Failure)
      if (id(wifi_component).is_ap_active()) {
        it.fill(id(my_color_black));
        it.print(64, 0, id(font_header), id(my_color_white), TextAlign::TOP_CENTER, "WIFI FAILED!");
        it.print(64, 16, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Connect to Hotspot:");
        it.print(64, 28, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Harem Fallback Hotspot");
        it.print(64, 40, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Pass: 4jNJPSLAfajjdHh3");
        it.print(64, 52, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "IP: 192.168.4.1");
        return; 
      }
      
      // 0A. CHECK SETTINGS MODE (Local)
      if (id(settings_mode)) {
         it.fill(id(my_color_black));
         it.filled_rectangle(0, 0, 128, 64, id(my_color_black)); // Ensure clear
         
         it.print(64, 0, id(font_small), TextAlign::TOP_CENTER, "- SETTINGS -");
         
         // Draw Battery % in top right
         it.printf(127, 0, id(font_small), TextAlign::TOP_RIGHT, "%.0f%%", id(battery_percent));
         
         int y_base = 20;
         int row_h = 10; // Tighter spacing for more info? No, keep generic 15 but scroll.
         
         // Menu Items:
         // 0: Brightness
         // 1: Standby
         // 2: Sleep
         // 3: WiFi: [SSID]
         // 4: IP: [IP]
          // 5: Exit
         
         // Draw 3 rows centered around selection
         // Draw 3 rows centered around selection (circularly wrapped)
         
         for (int i = 0; i < 3; i++) {
             int current_item = (id(settings_index) - 1 + i + 6) % 6;
             int y_pos = y_base + (i * 15);
             
             // Draw Caret
             auto current_font = (id(settings_index) == current_item) ? id(font_header) : id(font_small);

             if (id(settings_index) == current_item) 
                 it.print(0, y_pos, current_font, TextAlign::TOP_LEFT, ">");
                 
             // Draw Item Content
             if (current_item == 0) { // Brightness
                 if (id(edit_mode) && id(settings_index) == 0)
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Bright: [%d%%]", id(screen_brightness));
                 else
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Bright: %d%%", id(screen_brightness));
             }
             else if (current_item == 1) { // Standby
                 if (id(edit_mode) && id(settings_index) == 1)
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Standby: [%ds]", id(standby_duration_v2));
                 else
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Standby: %ds", id(standby_duration_v2));
             }
              else if (current_item == 2) { // Sleep (New)
                  if (id(edit_mode) && id(settings_index) == 2)
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Sleep: [%ds]", id(sleep_timeout_v2));
                  else
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Sleep: %ds", id(sleep_timeout_v2));
              }
             else if (current_item == 3) { // WiFi
                 if (id(wifi_ssid).has_state())
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "WiFi: %s", id(wifi_ssid).state.c_str());
                 else
                    it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "WiFi: Scanning...");
             }
             else if (current_item == 4) { // IP
                 if (id(wifi_ip).has_state())
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "IP: %s", id(wifi_ip).state.c_str());
                 else
                    it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "IP: N/A");
             }
             else if (current_item == 5) { // Exit
                 it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "Exit");
             }
         }
         return;
      }
      
      // 0B. CHECK OVERLAY (Feedback Screen)
      if (id(remote_overlay).has_state() && id(remote_overlay).state != "") {
         // Clear screen
         it.fill(id(my_color_black));
         
         // Draw Box
         it.filled_rectangle(0, 0, 128, 64, id(my_color_black));
         
         // Draw Text Centered
         it.print(64, 25, id(font_header), TextAlign::TOP_CENTER, id(remote_overlay).state.c_str());
         
         // Draw spinner/dots? (Optional, let's keep it simple first)
         return; // Skip drawing the rest
      }

      // Draw Interface - 5 Lines
      
      // Line 1 (Index - 2) - y=6 (Safe from Top Bezel)
      if (id(remote_line_1).has_state()) {
        it.printf(64, 6, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_1).state.c_str());
      }
      
      // Line 2 (Index - 1) - y=17
      if (id(remote_line_2).has_state()) {
        it.printf(64, 17, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_2).state.c_str());
      }

      // Line 3 (Selected) - Split Layout: Name (Scrolls) + Status (Fixed)
      if (id(remote_line_3).state != "") {
        int x1, y1, width, height;
        std::string status_text = id(remote_line_3_status).state;
        int status_width = 0;
        
        // 1. Calculate Status Width
        if (status_text != "") {
           it.get_text_bounds(0, 0, status_text.c_str(), id(font_small), TextAlign::TOP_LEFT, &x1, &y1, &status_width, &height);
           status_width += 4; // Add padding
        }

        int max_name_width = 128 - status_width;
        
        // 2. Draw Name (Scrolling logic using max_name_width)
        std::string name_text = id(remote_line_3).state;
        int name_width = 0;
        it.get_text_bounds(0, 0, name_text.c_str(), id(font_header), TextAlign::TOP_LEFT, &x1, &y1, &name_width, &height);
        
        if (name_width <= max_name_width) {
             // Fits in available space - Center it
             it.print(max_name_width / 2, 28, id(font_header), TextAlign::TOP_CENTER, name_text.c_str());
        } else {
             // Too long - Scroll it
             // Let's force it to be 0 if it fits, else calculate.
             int limit = name_width - max_name_width + 30; // 30px pause
             int step = (millis() / 50) % limit;
             int x_offset = (step > (name_width - max_name_width)) ? (name_width - max_name_width) : step;
             
             it.print(0 - x_offset, 28, id(font_header), TextAlign::TOP_LEFT, name_text.c_str());
        }

        // 3. Draw Status (Fixed Right)
        if (status_text != "") {
           // Clear background for status
           it.filled_rectangle(128 - status_width, 28, status_width, 14, id(my_color_black));
           it.print(128, 29, id(font_small), TextAlign::TOP_RIGHT, status_text.c_str());
        }
      } else {
        if (millis() < 3000) {
          // Splash Screen (First 3.0s)
          it.print(64, 0, id(font_header), TextAlign::TOP_CENTER, "HARem");
          it.print(64, 25, id(font_small), TextAlign::TOP_CENTER, "HomeAssistant Remote");
          it.print(64, 40, id(font_small), TextAlign::TOP_CENTER, "Controller");
        } else {
          // Waiting Screen (After 3.0s)
          it.print(64, 20, id(font_header), TextAlign::TOP_CENTER, "Waiting...");
          it.print(64, 50, id(font_small), TextAlign::TOP_CENTER, "${fw_version}");
        }
      }

      // Line 4 (Index + 1) - y=41
      if (id(remote_line_4).has_state()) {
        it.printf(64, 41, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_4).state.c_str());
      }

      // Line 5 (Index + 2) - y=52 (Safe from Bottom Bezel)
      if (id(remote_line_5).has_state()) {
        it.printf(64, 52, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_5).state.c_str());
      }



# Script removed - Logic moved to Home Assistant

script:
  - id: idle_timer
    mode: restart
    then:
      - lambda: 'id(my_display).turn_on(); id(is_awake) = true; id(sleep_countdown) = -1;'
      - delay: !lambda 'return id(standby_duration_v2) * 1000;'
      - lambda: 'id(my_display).turn_off(); id(is_awake) = false;'
      - delay: !lambda |-
          int total_ms = id(sleep_timeout_v2) * 1000;
          return (total_ms > 5000) ? (total_ms - 5000) : 0;
      - lambda: 'id(sleep_countdown) = 5; id(my_display).turn_on(); id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 4; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 3; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 2; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 1; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = -1; id(my_display).turn_off();'
      - logger.log: "Entering Deep Sleep..."
      - deep_sleep.enter: sleep_module

  - id: send_click_event
    mode: restart
    then:
      - script.execute: idle_timer
      - logger.log: "SUCCESS: Click Sent to HA"
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: click

  - id: send_back_event
    mode: restart
    then:
      - script.execute: idle_timer
      - logger.log: "SUCCESS: Back Sent to HA"
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: back

  - id: handle_settings_hold
    then:
      - delay: 4s
      - lambda: |-
          id(processed_settings_hold) = true;
          id(settings_mode) = !id(settings_mode);
          ESP_LOGD("main", "Auto-Settings Hold: settings_mode is now %s", id(settings_mode) ? "ON" : "OFF");
          id(edit_mode) = false;
          id(settings_index) = 0;
          id(my_display).turn_on();
          id(is_awake) = true;
