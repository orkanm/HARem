substitutions:
  name: "ha-remote"
  friendly_name: "HA Remote Controller"
  fw_version: "v0.2"

esphome:
  name: harem
  friendly_name: HARem
  on_boot:
    priority: 600
    then:
      - script.execute: idle_timer
      - lambda: 'id(my_display).set_contrast(id(screen_brightness) / 100.0);'

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG

preferences:
  flash_write_interval: 10s

# Enable Home Assistant API
api:
  encryption:
    key: !secret harem_api_key

ota:
  - platform: esphome
    password: !secret harem_ota_password

wifi:
  id: wifi_component
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password

    - ssid: !secret 2_wifi_ssid
      password: !secret 2_wifi_password

    - ssid: !secret 3_wifi_ssid
      password: !secret 3_wifi_password
    # Set a low power save mode to speed up the connection when waking up
  power_save_mode: LIGHT
  
  # Callback when Wi-Fi disconnects
  on_disconnect:
    - logger.log: "Wi-Fi disconnected!"
    - delay: 180s   # wait 3 minutes
    - if:
        condition:
          wifi.connected:
        then:
          - logger.log: "Wi-Fi reconnected within 3 minutes."
        else:
          - logger.log: "Wi-Fi still down, rebooting..."

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Harem Fallback Hotspot"
    password: !secret harem_ap_password

captive_portal:

# Colors
color:
  - id: my_color_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_color_black
    red: 0%
    green: 0%
    blue: 0%

# I2C Configuration for OLED
i2c:
  sda: GPIO5
  scl: GPIO6
  scan: true
  id: bus_a

# Font configuration
font:
  - file: "gfonts://Outfit"
    id: font_main
    size: 14
  - file: "gfonts://Material Icons"
    id: font_icon
    size: 24
    glyphs:
      - "\U0000E0F0" # lightbulb (was mdi-lightbulb-on)
      - "\U0000E8AC" # power_settings_new (was mdi-power-plug? using generic power for now)
      - "\U0000E335" # power_off (was mdi-lightbulb-off? using close/off)
      - "\U0000E02C" # movie
      - "\U0000E63C" # power (plug)
  - file: "gfonts://Montserrat"
    id: font_header
    size: 13
  - file: "gfonts://Outfit"
    id: font_small
    size: 10
  - file: "gfonts://Bebas Neue"
    id: font_count
    size: 32

# Globals to track state
globals:
  - id: is_awake
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: standby_duration_v2
    type: int
    restore_value: yes
    initial_value: '60'
  - id: screen_brightness
    type: int
    restore_value: yes
    initial_value: '100'
  - id: settings_mode
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: settings_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: edit_mode
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: press_time
    type: uint32_t
    initial_value: '0'
  - id: processed_settings_hold
    type: bool
    initial_value: 'false'
  - id: enable_animations_v2
    type: int
    restore_value: yes
    initial_value: '1'
  - id: battery_percent
    type: float
    initial_value: '100.0'
  - id: sleep_timeout_v2
    type: int
    restore_value: yes
    initial_value: '60'
  - id: sleep_countdown
    type: int
    initial_value: '-1'
  - id: sleep_start_ms
    type: uint32_t
    initial_value: '0'

# Import Home Assistant Entities
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      allow_other_uses: true
      inverted: true
    filters:
      - delayed_off: 2ms
    name: "Encoder Button"
    id: encoder_button
    on_press:
      - lambda: |-
          id(press_time) = millis();
          id(processed_settings_hold) = false;
      - script.execute: handle_settings_hold
    on_release:
      - script.stop: handle_settings_hold
      - lambda: |-
          if (id(processed_settings_hold)) return;
          
          uint32_t duration = millis() - id(press_time);
          if (duration < 10) return; // Debounce
          
          if (duration < 800) {
            // SHORT CLICK
            if (id(settings_mode)) {
               id(idle_timer)->execute();
               if (id(settings_index) == 6) {
                 ESP_LOGD("main", "Settings Exit item clicked");
                 id(settings_mode) = false;
                 id(edit_mode) = false;
               } else if (id(settings_index) < 4) {
                 id(edit_mode) = !id(edit_mode);
               }
            } else {
               if (id(is_awake)) {
                 id(send_click_event)->execute();
               } else {
                 id(idle_timer)->execute();
               }
            }
          } else if (duration >= 800 && duration < 3500) {
            // BACK ACTION
            if (id(settings_mode)) {
               ESP_LOGD("main", "Exiting Settings via 1s hold");
               id(settings_mode) = false;
               id(edit_mode) = false;
            } else {
               id(send_back_event)->execute();
            }
          }

text_sensor:
  - platform: homeassistant
    id: remote_line_1
    entity_id: input_text.harem_line_1
  - platform: homeassistant
    id: remote_line_2
    entity_id: input_text.harem_line_2
  - platform: homeassistant
    id: remote_line_3
    entity_id: input_text.harem_line_3
  - platform: homeassistant
    id: remote_line_4
    entity_id: input_text.harem_line_4
  - platform: homeassistant
    id: remote_line_5
    entity_id: input_text.harem_line_5

  - platform: homeassistant
    id: remote_line_3_status
    entity_id: input_text.harem_line_3_status
  - platform: homeassistant
    id: remote_overlay
    entity_id: input_text.harem_overlay

  - platform: wifi_info
    ip_address:
      id: wifi_ip
    ssid:
      id: wifi_ssid

sensor:
  - platform: rotary_encoder
    id: encoder
    pin_a:
      number: GPIO8
      mode: INPUT_PULLUP
    pin_b:
      number: GPIO9
      mode: INPUT_PULLUP
    resolution: 1
    on_clockwise:
      - script.execute: idle_timer
      - if:
          condition: 
            lambda: 'return id(settings_mode);'
          then:
             - if:
                 condition:
                   lambda: 'return id(edit_mode);'
                 then:
                   # Adjust Value (+)
                    - lambda: |-
                        bool changed = false;
                        if (id(settings_index) == 0) { // Brightness
                           if (id(screen_brightness) < 100) {
                               id(screen_brightness) += 10;
                               id(my_display).set_contrast(id(screen_brightness) / 100.0);
                               changed = true;
                           }
                        } else if (id(settings_index) == 1) { // Standby
                           if (id(standby_duration_v2) < 300) {
                               id(standby_duration_v2) += 10;
                               changed = true;
                           }
                        } else if (id(settings_index) == 2) { // Sleep
                           if (id(sleep_timeout_v2) < 120) {
                               id(sleep_timeout_v2) += 10;
                               changed = true;
                           }
                        } else if (id(settings_index) == 3) { // Animations
                           id(enable_animations_v2) = (id(enable_animations_v2) == 1) ? 0 : 1;
                           changed = true;
                        }
                        if (changed) id(my_display).update();
                 else:
                   # Move Down (Wrapped)
                   - lambda: |-
                       // 0:Bright, 1:Standby, 2:Sleep, 3:Animations, 4:WiFi, 5:IP, 6:Exit
                       id(settings_index)++;
                       if (id(settings_index) > 6) id(settings_index) = 0;
                       id(my_display).update();
          else:
            - homeassistant.event:
                event: esphome.remote_action
                data:
                  action: next

    on_anticlockwise:
      - script.execute: idle_timer
      - if:
          condition: 
            lambda: 'return id(settings_mode);'
          then:
             - if:
                 condition:
                   lambda: 'return id(edit_mode);'
                 then:
                   # Adjust Value (-)
                    - lambda: |-
                        bool changed = false;
                        if (id(settings_index) == 0) { // Brightness
                           if (id(screen_brightness) > 10) {
                               id(screen_brightness) -= 10;
                               id(my_display).set_contrast(id(screen_brightness) / 100.0);
                               changed = true;
                           }
                        } else if (id(settings_index) == 1) { // Standby
                           if (id(standby_duration_v2) > 10) {
                               id(standby_duration_v2) -= 10;
                               changed = true;
                           }
                        } else if (id(settings_index) == 2) { // Sleep
                           if (id(sleep_timeout_v2) > 10) {
                               id(sleep_timeout_v2) -= 10;
                               changed = true;
                           }
                        } else if (id(settings_index) == 3) { // Animations
                           id(enable_animations_v2) = (id(enable_animations_v2) == 1) ? 0 : 1;
                           changed = true;
                        }
                        if (changed) id(my_display).update();
                 else:
                   # Move Up (Wrapped)
                   - lambda: |-
                       if (id(settings_index) == 0) {
                           id(settings_index) = 6;
                       } else {
                           id(settings_index)--;
                       }
                       id(my_display).update();
          else:
            - homeassistant.event:
                event: esphome.remote_action
                data:
                  action: prev

  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_sensor
    update_interval: 60s

  - platform: adc
    pin: GPIO0
    name: "Battery Voltage"
    id: battery_voltage_adc
    update_interval: 60s
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      - multiply: 2.0 
    on_value:
      then:
        - lambda: |-
            id(battery_percent) = (x - 3.2) / (4.2 - 3.2) * 100.0;
            if (id(battery_percent) > 100) id(battery_percent) = 100;
            if (id(battery_percent) < 0) id(battery_percent) = 0;
            id(my_display).update();

deep_sleep:
  id: sleep_module
  sleep_duration: 1d
  wakeup_pin:
    number: GPIO4
    inverted: true
    mode: INPUT_PULLUP
    allow_other_uses: true

display:
  - platform: ssd1306_i2c
    model: "SH1106 128x64"
    address: 0x3C
    id: my_display
    i2c_id: bus_a
    update_interval: 0.1s
    lambda: |-
      // Draw Interface
      
      // 00B. CHECK FOR SLEEP COUNTDOWN
      if (id(sleep_countdown) > 0) {
        it.fill(id(my_color_black));
        
        // Breathing effect for "SLEEPING"
        float pulse = 0;
        if (id(enable_animations_v2) == 1) pulse = sin(millis() * 0.005) * 5.0; 
        it.print(64, 4 + pulse, id(font_header), TextAlign::TOP_CENTER, "SLEEPING");
        
        it.printf(64, 34, id(font_count), TextAlign::CENTER, "%d", id(sleep_countdown));
        
        // Smooth Progress Bar
        int bar_w = 80;
        int bar_h = 4;
        int bar_x = (128 - bar_w) / 2;
        int bar_y = 54;
        
        uint32_t elapsed = millis() - id(sleep_start_ms);
        float progress = 1.0f - (elapsed / 5000.0f);
        if (progress < 0) progress = 0;
        
        it.rectangle(bar_x, bar_y, bar_w, bar_h, id(my_color_white));
        if (id(enable_animations_v2) == 1) {
            it.filled_rectangle(bar_x, bar_y, (int)(bar_w * progress), bar_h, id(my_color_white));
        } else {
            it.filled_rectangle(bar_x, bar_y, (int)(bar_w * (id(sleep_countdown)/5.0f)), bar_h, id(my_color_white));
        }
        
        return;
      }

      // 00. CHECK FOR HOTSPOT MODE (WiFi Failure)
      if (id(wifi_component).is_ap_active()) {
        it.fill(id(my_color_black));
        it.print(64, 0, id(font_header), id(my_color_white), TextAlign::TOP_CENTER, "WIFI FAILED!");
        it.print(64, 16, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Connect to Hotspot:");
        it.print(64, 28, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Harem Fallback Hotspot");
        it.print(64, 40, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Pass: 4jNJPSLAfajjdHh3");
        it.print(64, 52, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "IP: 192.168.4.1");
        return; 
      }
      
      // 0A. CHECK SETTINGS MODE (Local)
      if (id(settings_mode)) {
         it.fill(id(my_color_black));
         it.filled_rectangle(0, 0, 128, 64, id(my_color_black)); // Ensure clear
         
         it.print(64, 0, id(font_small), TextAlign::TOP_CENTER, "- SETTINGS -");
         
         // Draw Battery % in top right
         it.printf(127, 0, id(font_small), TextAlign::TOP_RIGHT, "%.0f%%", id(battery_percent));
         
         int y_base = 20;
         
         for (int i = 0; i < 3; i++) {
              int current_item = (id(settings_index) - 1 + i + 7) % 7;
              int y_pos = y_base + (i * 15);
              
              // Draw Caret
              auto current_font = (id(settings_index) == current_item) ? id(font_header) : id(font_small);

              if (id(settings_index) == current_item) 
                  it.print(0, y_pos, current_font, TextAlign::TOP_LEFT, ">");
                  
              // Draw Item Content
              if (current_item == 0) { // Brightness
                  if (id(edit_mode) && id(settings_index) == 0)
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Bright: [%d%%]", id(screen_brightness));
                  else
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Bright: %d%%", id(screen_brightness));
              }
              else if (current_item == 1) { // Standby
                  if (id(edit_mode) && id(settings_index) == 1)
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Standby: [%ds]", id(standby_duration_v2));
                  else
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Standby: %ds", id(standby_duration_v2));
              }
              else if (current_item == 2) { // Sleep
                   if (id(edit_mode) && id(settings_index) == 2)
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Sleep: [%ds]", id(sleep_timeout_v2));
                   else
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Sleep: %ds", id(sleep_timeout_v2));
              }
              else if (current_item == 3) { // Animations
                   if (id(edit_mode) && id(settings_index) == 3)
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Anim: [%s]", (id(enable_animations_v2) == 1) ? "ON" : "OFF");
                   else
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Anim: %s", (id(enable_animations_v2) == 1) ? "ON" : "OFF");
              }
              else if (current_item == 4) { // WiFi
                  if (id(wifi_ssid).has_state())
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "WiFi: %s", id(wifi_ssid).state.c_str());
                  else
                     it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "WiFi: Scanning...");
              }
              else if (current_item == 5) { // IP
                  if (id(wifi_ip).has_state())
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "IP: %s", id(wifi_ip).state.c_str());
                  else
                     it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "IP: N/A");
              }
              else if (current_item == 6) { // Exit
                  it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "Exit");
              }
         }
         return;
      }
      
      // 0B. CHECK OVERLAY (Feedback Screen)
      if (id(remote_overlay).has_state() && id(remote_overlay).state != "") {
         it.fill(id(my_color_black));
         
         // Breathing pulse for feedback text
         float pulse = 0;
         if (id(enable_animations_v2) == 1) pulse = sin(millis() * 0.008) * 3.0;
         it.print(64, 25 + pulse, id(font_header), TextAlign::TOP_CENTER, id(remote_overlay).state.c_str());
         
         if (id(enable_animations_v2) == 1) {
           // Small minimalist animated bar
           int bar_w = 40;
           int bar_x = (128 - bar_w) / 2;
           float bar_pulse = (sin(millis() * 0.008) + 1.0) / 2.0; // 0.0 to 1.0
           it.line(bar_x, 45, bar_x + (int)(bar_w * bar_pulse), 45, id(my_color_white));
         }
         
         return;
      }

      // Draw Interface - 5 Lines
      if (id(remote_line_1).has_state()) it.printf(64, 6, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_1).state.c_str());
      if (id(remote_line_2).has_state()) it.printf(64, 17, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_2).state.c_str());

      if (id(remote_line_3).state != "") {
        int x1, y1, width, height;
        std::string status_text = id(remote_line_3_status).state;
        int status_width = 0;
        if (status_text != "") {
           it.get_text_bounds(0, 0, status_text.c_str(), id(font_small), TextAlign::TOP_LEFT, &x1, &y1, &status_width, &height);
           status_width += 4;
        }
        int max_name_width = 128 - status_width;
        std::string name_text = id(remote_line_3).state;
        int name_width = 0;
        it.get_text_bounds(0, 0, name_text.c_str(), id(font_header), TextAlign::TOP_LEFT, &x1, &y1, &name_width, &height);
        
        if (name_width <= max_name_width) {
             it.print(max_name_width / 2, 28, id(font_header), id(my_color_white), TextAlign::TOP_CENTER, name_text.c_str());
        } else {
             int limit = name_width - max_name_width + 30;
             int step = (millis() / 50) % limit;
             int x_offset = (step > (name_width - max_name_width)) ? (name_width - max_name_width) : step;
             it.print(0 - x_offset, 28, id(font_header), id(my_color_white), TextAlign::TOP_LEFT, name_text.c_str());
        }
        if (status_text != "") {
           it.filled_rectangle(128 - status_width, 28, status_width, 14, id(my_color_black));
           it.print(128, 29, id(font_small), id(my_color_white), TextAlign::TOP_RIGHT, status_text.c_str());
        }
      } else {
        if (millis() < 3000) {
          it.print(64, 0, id(font_header), TextAlign::TOP_CENTER, "HARem");
          it.print(64, 25, id(font_small), TextAlign::TOP_CENTER, "HomeAssistant Remote");
          it.print(64, 40, id(font_small), TextAlign::TOP_CENTER, "Controller");
        } else {
          it.fill(id(my_color_black));
          float pulse = 0;
          if (id(enable_animations_v2) == 1) pulse = sin(millis() * 0.005) * 2.0;
          it.print(64, 15 + pulse, id(font_header), TextAlign::TOP_CENTER, "CONNECTING");
          int container_w = 100;
          int bar_w = 30;
          int start_x = (128 - container_w) / 2;
          if (id(enable_animations_v2) == 1) {
             int t = (millis() / 8) % 200;
             int pos = (t > 100) ? (200 - t) : t;
             int x_bar = start_x + (int)(pos * (container_w - bar_w) / 100.0f);
             it.rectangle(start_x, 40, container_w, 3, id(my_color_white));
             it.filled_rectangle(x_bar, 40, bar_w, 3, id(my_color_white));
          } else {
             it.rectangle(start_x, 40, container_w, 3, id(my_color_white));
             it.filled_rectangle(start_x + (container_w - bar_w)/2, 40, bar_w, 3, id(my_color_white));
          }
          it.print(64, 50, id(font_small), TextAlign::TOP_CENTER, "${fw_version}");
        }
      }

      if (id(remote_line_4).has_state()) it.printf(64, 41, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_4).state.c_str());
      if (id(remote_line_5).has_state()) it.printf(64, 52, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_5).state.c_str());

script:
  - id: idle_timer
    mode: restart
    then:
      - lambda: 'id(my_display).turn_on(); id(is_awake) = true; id(sleep_countdown) = -1;'
      - delay: !lambda 'return id(standby_duration_v2) * 1000;'
      - lambda: 'id(my_display).turn_off(); id(is_awake) = false;'
      - delay: !lambda |-
          int total_ms = id(sleep_timeout_v2) * 1000;
          return (total_ms > 5000) ? (total_ms - 5000) : 0;
      - lambda: 'id(sleep_countdown) = 5; id(sleep_start_ms) = millis(); id(my_display).turn_on(); id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 4; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 3; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 2; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 1; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = -1; id(my_display).turn_off();'
      - logger.log: "Entering Deep Sleep..."
      - deep_sleep.enter: sleep_module

  - id: send_click_event
    mode: restart
    then:
      - script.execute: idle_timer
      - logger.log: "SUCCESS: Click Sent to HA"
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: click

  - id: send_back_event
    mode: restart
    then:
      - script.execute: idle_timer
      - logger.log: "SUCCESS: Back Sent to HA"
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: back

  - id: handle_settings_hold
    then:
      - delay: 4s
      - lambda: |-
          id(processed_settings_hold) = true;
          id(settings_mode) = !id(settings_mode);
          ESP_LOGD("main", "Auto-Settings Hold: settings_mode is now %s", id(settings_mode) ? "ON" : "OFF");
          id(edit_mode) = false;
          id(settings_index) = 0;
          id(my_display).turn_on();
          id(is_awake) = true;
