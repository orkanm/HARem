# HARem - Home Assistant Remote Controller
# Maintained by Orkan Murat Celik

substitutions:
  name: "ha-remote"
  friendly_name: "HA Remote Controller"
  fw_version: "v0.6.2"
  log_level: "INFO" # DEBUG, INFO, WARNING, ERROR, NONE

dashboard_import:
  package_import_url: github://orkanm/HARem/remote_controller.yaml

esphome:
  name: harem
  friendly_name: HARem
  project:
    name: "orkanm.harem"
    version: "0.6.2"
  on_boot:
    - priority: 800
      then:
        - lambda: |-
            gpio_hold_dis(GPIO_NUM_1); 
            id(oled_power).turn_on();
            // Force reset UI states on boot to prevent stuck screens
            id(settings_mode) = false;
            id(edit_mode) = false;
            id(control_mode) = false;
            id(guest_pin_mode) = false;
            id(pin_change_stage) = 0;
            id(input_pin) = 0;
        - delay: 100ms # Give OLED time to power up
    - priority: 500
      then:
        - script.execute: idle_timer
        - lambda: 'id(my_display).set_contrast(id(screen_brightness) / 100.0);'
    - priority: 400  # After idle_timer starts
      then:
        - lambda: |-
            if (id(battery_percent) < 90.0) {
              id(show_low_battery_warning) = true;
              id(my_display).update();
            }
        - delay: 3s  # Show warning for 3 seconds
        - lambda: |-
            id(show_low_battery_warning) = false;


esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable Improv via Serial for easy provisioning
improv_serial:

# Enable logging
logger:
  level: ${log_level}

preferences:
  flash_write_interval: 10s

# Enable Home Assistant API
api:
  id: api_server
  encryption:
    key: !secret harem_api_key

ota:
  - platform: esphome
    on_begin:
      then:
        - script.stop: idle_timer
        - lambda: |-
            id(ota_active) = true;
            id(is_awake) = true;
            id(my_display).turn_on();
    on_progress:
      then:
        - lambda: |-
            id(ota_progress) = x;
            id(my_display).update();
    on_end:
      then:
        - lambda: |-
            id(ota_progress) = 100;
            id(my_display).update();
        - delay: 1s
    password: !secret harem_ota_password

wifi:
  id: wifi_component
  fast_connect: true
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password

    - ssid: !secret 2_wifi_ssid
      password: !secret 2_wifi_password

    - ssid: !secret 3_wifi_ssid
      password: !secret 3_wifi_password
    # Set a low power save mode to speed up the connection when waking up
  power_save_mode: LIGHT
  
  # Callback when Wi-Fi disconnects
  on_disconnect:
    - logger.log: "Wi-Fi disconnected!"
    - delay: 180s   # wait 3 minutes
    - if:
        condition:
          wifi.connected:
        then:
          - logger.log: "Wi-Fi reconnected within 3 minutes."
        else:
          - logger.log: "Wi-Fi still down, rebooting..."

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Harem Fallback Hotspot"
    password: !secret harem_ap_password

captive_portal:

# Colors
color:
  - id: my_color_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_color_black
    red: 0%
    green: 0%
    blue: 0%

# I2C Configuration for OLED
i2c:
  sda: GPIO5
  scl: GPIO6
  frequency: 900kHz
  scan: true
  id: bus_a

# Font configuration
font:
  - file: "gfonts://Outfit"
    id: font_main
    size: 14
  - file: "gfonts://Material Icons"
    id: font_icon
    size: 24
    glyphs:
      - "\U0000E0F0" # lightbulb (was mdi-lightbulb-on)
      - "\U0000E8AC" # power_settings_new (was mdi-power-plug? using generic power for now)
      - "\U0000E335" # power_off (was mdi-lightbulb-off? using close/off)
      - "\U0000E02C" # movie
      - "\U0000E63C" # power (plug)
  - file: "gfonts://Montserrat"
    id: font_header
    size: 13
  - file: "gfonts://Outfit"
    id: font_small
    size: 10
  - file: "gfonts://Bebas Neue"
    id: font_count
    size: 32
  - file: "gfonts://Outfit"
    id: font_medium
    size: 18

# Globals to track state
globals:
  - id: is_awake
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: last_wifi_switch_ms
    type: uint32_t
    initial_value: '0'
  - id: standby_duration_v2
    type: int
    restore_value: yes
    initial_value: '60'

  - id: screen_brightness
    type: int
    restore_value: yes
    initial_value: '100'
  - id: settings_mode
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: settings_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: edit_mode
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: press_time
    type: uint32_t
    initial_value: '0'
  - id: processed_settings_hold
    type: bool
    initial_value: 'false'
  - id: processed_rotate_hold
    type: bool
    initial_value: 'false'
  - id: pending_response
    type: bool
    initial_value: 'false'
  - id: last_action_ms
    type: uint32_t
    initial_value: '0'
  - id: offline_prompt_active
    type: bool
    initial_value: 'false'
  - id: is_scanning
    type: bool
    initial_value: 'false'
  - id: control_mode
    type: bool
    initial_value: 'false'
  - id: last_control_exit
    type: uint32_t
    initial_value: '0'
  - id: local_overlay_msg
    type: std::string
    initial_value: '""'
  - id: enable_animations_v2
    type: int
    restore_value: yes
    initial_value: '1'
  - id: battery_percent
    type: float
    initial_value: '100.0'
  - id: sleep_timeout_v2
    type: int
    restore_value: yes
    initial_value: '60'
  - id: sleep_countdown
    type: int
    initial_value: '-1'
  - id: sleep_start_ms
    type: uint32_t
  - id: guest_pin_mode
    type: bool
    initial_value: 'false'
  - id: input_pin
    type: int
    initial_value: '0'
  - id: pin_error_state
    type: bool
    initial_value: 'false'
  - id: ota_active
    type: bool
    initial_value: 'false'
  - id: ota_progress
    type: int
    initial_value: '0'
  - id: stored_pin
    type: int
    restore_value: yes
    initial_value: '00'
  - id: pin_change_stage
    type: int
    initial_value: '0' # 0=Idle, 1=VerifyOld, 2=SetNew, 3=ConfirmNew
  - id: temp_new_pin
    type: int
    initial_value: '0'
  - id: left_hand_mode
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: show_low_battery_warning
    type: bool
    initial_value: 'false'

# Import Home Assistant Entities
binary_sensor:
  - platform: homeassistant
    id: guest_mode_state
    entity_id: input_boolean.harem_guest_mode

  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      allow_other_uses: true
      inverted: true
    filters:
      - delayed_off: 2ms
    name: "Encoder Button"
    id: encoder_button
    on_press:
      - script.stop: idle_timer
      - lambda: |-
          id(press_time) = millis();
          id(processed_settings_hold) = false;
          id(processed_rotate_hold) = false;

          // If offline prompt is active, ignore hold logic
          if (id(offline_prompt_active)) return;
          // Block inputs during scanning
          if (id(is_scanning)) return;

      - script.execute: handle_settings_hold
    on_release:
      - script.stop: handle_settings_hold
      - lambda: |-
          // If we were asleep (screen off), wake up but ignore the click
          if (!id(is_awake)) {
              id(idle_timer)->execute(); // Turn on screen, set is_awake=true
              return;
          }
          
          // Restart Idle Timer (keep awake)
          id(idle_timer)->execute();

          if (id(processed_settings_hold)) return;
          if (id(is_scanning)) return;
          
          uint32_t duration = millis() - id(press_time);
          if (duration < 10) return; // Debounce
          
          // Handling "Sloppy Clicks" in Lock Mode:
          // If in Lock Mode, ignore accidental "wiggles" (short rotations) and allow them to act as Exit Clicks.
          // Only true "Press & Twist" gestures (>300ms) should consume the event and stay in mode.
          if (id(control_mode)) {
              if (id(processed_rotate_hold)) {
                 id(processed_rotate_hold) = false;
                 return;
              }
          } else {
              if (id(processed_rotate_hold)) {
                 id(processed_rotate_hold) = false;
                 return;
              }
          }
          
          if (duration < 800) {
            // SHORT CLICK

            // OFFLINE PROMPT CLICK
            if (id(offline_prompt_active)) {
               id(offline_prompt_active) = false;
               id(wifi_manual_reconnect)->execute();
               id(my_display).update();
               return;
            }

            if (id(control_mode)) {
                id(control_mode) = false;
                id(last_control_exit) = millis();
                id(send_clear_overlay_event)->execute();
                id(my_display).update();
                return;
            }

            if (id(settings_mode)) {
               id(idle_timer)->execute();
               

               // PIN MODE CLICK (Guest Unlock & PIN Change)
               if (id(guest_pin_mode)) {
                  // MODE A: Unlock Guest Mode
                  if (!id(pin_change_stage)) {
                      if (id(input_pin) == id(stored_pin)) {
                          id(send_toggle_guest_event)->execute();
                          id(guest_pin_mode) = false;
                          id(pin_error_state) = false;
                          id(settings_mode) = false;
                      } else {
                          id(pin_error_state) = true;
                          id(input_pin) = 0;
                      }
                      id(my_display).update();
                      return;
                  } 
                  
                  // MODE B: Change PIN Flow
                  if (id(pin_change_stage) == 1) { // Verify Old
                      if (id(input_pin) == id(stored_pin)) {
                          id(pin_change_stage) = 2; // Success -> Go to New
                          id(input_pin) = 0;
                          id(pin_error_state) = false;
                      } else {
                          id(pin_error_state) = true;
                          id(input_pin) = 0;
                      }
                  } else if (id(pin_change_stage) == 2) { // Set New
                      id(temp_new_pin) = id(input_pin); // STORE TEMP
                      id(pin_change_stage) = 3; // Go to Confirm
                      id(input_pin) = 0;
                      id(pin_error_state) = false;
                  } else if (id(pin_change_stage) == 3) { // Confirm New
                      if (id(input_pin) == id(temp_new_pin)) {
                          id(stored_pin) = id(temp_new_pin); // SAVE!
                          id(pin_change_stage) = 4; // Show Success
                          id(pin_success_sequence)->execute();
                      } else {
                          id(pin_error_state) = true; // MATCH FAIL
                          id(input_pin) = 0;
                          // Optional: Reset to Stage 2? Keeping at 3 for retry.
                      }
                  }
                  id(my_display).update();
                  return;
               }

               if (id(settings_index) == 9) { // Exit (shifted to 9)
                 id(settings_mode) = false;
                 id(edit_mode) = false;
                 id(my_display).update();
               } else if (id(settings_index) == 7) { // WiFi Manual Scan (Item 7)
                  id(wifi_manual_reconnect)->execute();
                  id(my_display).update();
               } else if (id(settings_index) == 6) { // Change PIN (shifted to 6)
                  id(guest_pin_mode) = true;
                  id(pin_change_stage) = 1; // Start Verify Flow
                  id(input_pin) = 0;
                  id(pin_error_state) = false;
                  id(my_display).update();
               } else if (id(settings_index) == 5) { // Left Hand Mode toggle
                  id(left_hand_mode) = !id(left_hand_mode);
                  id(my_display).update();
               } else if (id(settings_index) == 4) { // Guest Mode toggle
                 if (id(guest_mode_state).state) {
                    // IF ON: Require PIN to turn OFF
                    id(guest_pin_mode) = true;
                    id(input_pin) = 0;
                    id(pin_error_state) = false;
                    id(my_display).update();
                 } else {
                    // IF OFF: Toggle freely
                    id(send_toggle_guest_event)->execute();
                 }
               } else if (id(settings_index) < 4) { // Editable items (0,1,2,3)
                 id(edit_mode) = !id(edit_mode);
                 id(my_display).update();
               }
            } else {
               if (id(is_awake)) {
                  // Only show prompt if we have previously loaded UI (line 3 has content)
                  // AND it's been > 10s (double safety)
                  if (millis() > 10000 && !id(api_server).is_connected() && id(remote_line_3).state.length() > 0) {
                     id(offline_prompt_active) = true;
                     id(my_display).update();
                     return;
                  }
                 id(send_click_event)->execute();
               } else {
                 id(idle_timer)->execute();
               }
            }
          } else if (duration >= 800 && duration < 3500) {
            // BACK ACTION
            if (id(settings_mode)) {
               if (id(guest_pin_mode)) {
                   id(guest_pin_mode) = false; // Cancel PIN
                   id(my_display).update();
               } else {
                   ESP_LOGD("main", "Exiting Settings via 1s hold");
                   id(settings_mode) = false;
                  id(edit_mode) = false;
                  id(pending_response) = false;
               }
            } else {
               id(send_back_event)->execute();
            }
          }

text_sensor:
  - platform: homeassistant
    id: remote_line_1
    entity_id: input_text.harem_line_1
    on_value:
      then:
        - lambda: 'id(pending_response) = false;'
  - platform: homeassistant
    id: remote_line_2
    entity_id: input_text.harem_line_2
    on_value:
      then:
        - lambda: 'id(pending_response) = false;'
  - platform: homeassistant
    id: remote_line_3
    entity_id: input_text.harem_line_3
    on_value:
      then:
        - lambda: 'id(pending_response) = false;'
  - platform: homeassistant
    id: remote_line_3_status
    entity_id: input_text.harem_line_3_status
    on_value:
      then:
        - lambda: 'id(pending_response) = false;'
  - platform: homeassistant
    id: remote_line_4
    entity_id: input_text.harem_line_4
    on_value:
      then:
        - lambda: 'id(pending_response) = false;'
  - platform: homeassistant
    id: remote_line_5
    entity_id: input_text.harem_line_5
    on_value:
      then:
        - lambda: 'id(pending_response) = false;'

  - platform: homeassistant
    id: remote_overlay
    entity_id: input_text.harem_overlay
    on_value:
      then:
        - lambda: 'id(pending_response) = false;'

  - platform: wifi_info
    ip_address:
      id: wifi_ip
    ssid:
      id: wifi_ssid



sensor:
  - platform: rotary_encoder
    id: encoder
    pin_a:
      number: GPIO9
      mode: INPUT_PULLUP
    pin_b:
      number: GPIO8
      mode: INPUT_PULLUP
    resolution: 1
    on_clockwise:
      - script.execute: idle_timer
      - lambda: |-
          if (id(is_scanning)) return;
          // Block rotation if UI is not ready (Boot/Connecting screens)
          if (id(remote_line_3).state.length() == 0) return;

          if (id(encoder_button).state) {
            // Check if status contains '*' (dimmable)
            std::string st = id(remote_line_3_status).state;
            if (st.find("*") == std::string::npos) {
                 id(processed_rotate_hold) = true;
                 id(show_local_warning)->execute();
                 return; // Not dimmable, show warning
            }
            
            id(processed_rotate_hold) = true;
            id(control_mode) = true;
            id(handle_settings_hold)->stop();
            id(send_rotate_cw_hold_event)->execute();
            return;
          }
          if (id(control_mode)) {
            id(send_rotate_cw_hold_event)->execute();
            return;
          }
 
          if (millis() - id(last_control_exit) < 500) return;

      - if:
          condition: 
            lambda: 'return id(settings_mode);'
          then:
             - if:
                 condition:
                   lambda: 'return id(guest_pin_mode);'
                 then:
                   - lambda: |-
                       id(input_pin)++;
                       if (id(input_pin) > 99) id(input_pin) = 0;
                       id(pin_error_state) = false; 
                       id(my_display).update();
             - if:
                 condition:
                   lambda: 'return (id(edit_mode) && !id(guest_pin_mode));'
                 then:
                   # Adjust Value (+)
                    - lambda: |-
                        bool changed = false;
                        if (id(settings_index) == 0) { // Brightness
                           if (id(screen_brightness) < 100) {
                               id(screen_brightness) += 10;
                               id(my_display).set_contrast(id(screen_brightness) / 100.0);
                               changed = true;
                           }
                        } else if (id(settings_index) == 1) { // Standby
                           if (id(standby_duration_v2) < 300) {
                               id(standby_duration_v2) += 10;
                               changed = true;
                           }
                        } else if (id(settings_index) == 2) { // Sleep
                           if (id(sleep_timeout_v2) < 300) {
                               id(sleep_timeout_v2) += 10;
                               changed = true;
                           }
                        } else if (id(settings_index) == 3) { // Animations

                           id(enable_animations_v2) = (id(enable_animations_v2) == 1) ? 0 : 1;
                           changed = true;
                        }
                        if (changed) id(my_display).update();
                 else:
                   # Move Down (Wrapped)
                   - lambda: |-
                       // 0:Bright, 1:Standby, 2:Sleep, 3:Animations, 4:Guest, 5:LeftHand, 6:ChangePIN, 7:SSID, 8:IP, 9:Exit
                       id(settings_index)++;
                       if (id(settings_index) > 9) id(settings_index) = 0;
                       id(my_display).update();
          else:
            - if:
                condition:
                  lambda: 'return !id(control_mode) && !id(processed_rotate_hold);'
                then:
                   - if:
                       condition:
                          lambda: "return millis() > 10000 && !id(api_server).is_connected() && id(remote_line_3).state.length() > 0;"
                       then:
                         - lambda: |-
                             id(offline_prompt_active) = true;
                             id(my_display).update();
                       else:
                         - homeassistant.event:
                             event: esphome.remote_action
                             data:
                               action: next
                         - lambda: |-
                             id(pending_response) = true;
                             id(last_action_ms) = millis();

    on_anticlockwise:
      - script.execute: idle_timer
      - lambda: |-
          if (id(is_scanning)) return;
          // Block rotation if UI is not ready (Boot/Connecting screens)
          if (id(remote_line_3).state.length() == 0) return;

          // Dismiss offline prompt on rotation
          if (id(offline_prompt_active)) {
              id(offline_prompt_active) = false;
              id(my_display).update();
              return;
          }

          if (id(encoder_button).state) {
            // Check if status contains '*' (dimmable)
            std::string st = id(remote_line_3_status).state;
            if (st.find("*") == std::string::npos) {
                 id(processed_rotate_hold) = true;
                 id(show_local_warning)->execute();
                 return; // Not dimmable, show warning
            }
            
            id(processed_rotate_hold) = true;
            id(control_mode) = true;
            id(handle_settings_hold)->stop();
            id(send_rotate_ccw_hold_event)->execute();
            return;
          }
          if (id(control_mode)) {
            id(send_rotate_ccw_hold_event)->execute();
            return;
          }
 
          if (millis() - id(last_control_exit) < 500) return;

      - if:
          condition: 
            lambda: 'return id(settings_mode);'
          then:
             - if:
                 condition:
                   lambda: 'return id(guest_pin_mode);'
                 then:
                   - lambda: |-
                       id(input_pin)--;
                       if (id(input_pin) < 0) id(input_pin) = 99;
                       id(pin_error_state) = false;
                       id(my_display).update();
             - if:
                 condition:
                   lambda: 'return (id(edit_mode) && !id(guest_pin_mode));'
                 then:
                   # Adjust Value (-)
                    - lambda: |-
                        bool changed = false;
                        if (id(settings_index) == 0) { // Brightness
                           if (id(screen_brightness) > 10) {
                               id(screen_brightness) -= 10;
                               id(my_display).set_contrast(id(screen_brightness) / 100.0);
                               changed = true;
                           }
                        } else if (id(settings_index) == 1) { // Standby
                           if (id(standby_duration_v2) > 10) {
                               id(standby_duration_v2) -= 10;
                               changed = true;
                           }
                        } else if (id(settings_index) == 2) { // Sleep
                           if (id(sleep_timeout_v2) > 10) {
                               id(sleep_timeout_v2) -= 10;
                               changed = true;
                           }
                        } else if (id(settings_index) == 3) { // Animations

                           id(enable_animations_v2) = (id(enable_animations_v2) == 1) ? 0 : 1;
                           changed = true;
                        }
                        if (changed) id(my_display).update();
                 else:
                   # Move Up (Wrapped)
                   - lambda: |-
                       // 0:Bright, 1:Standby, 2:Sleep, 3:Animations, 4:Guest, 5:LeftHand, 6:ChangePIN, 7:SSID, 8:IP, 9:Exit
                       if (id(settings_index) == 0) {
                           id(settings_index) = 9;
                       } else {
                           id(settings_index)--;
                       }
                       id(my_display).update();
          else:
            - if:
                condition:
                  lambda: 'return !id(control_mode) && !id(processed_rotate_hold);'
                then:
                   - if:
                       condition:
                          lambda: "return millis() > 10000 && !id(api_server).is_connected() && id(remote_line_3).state.length() > 0;"
                       then:
                         - lambda: |-
                             id(offline_prompt_active) = true;
                             id(my_display).update();
                       else:
                         - homeassistant.event:
                             event: esphome.remote_action
                             data:
                               action: prev
                         - lambda: |-
                             id(pending_response) = true;
                             id(last_action_ms) = millis();

  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_sensor
    update_interval: 60s

  - platform: adc
    pin: GPIO0
    name: "Battery Voltage"
    id: battery_voltage_adc
    update_interval: 60s
    attenuation: 12db
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      # Hardware: Voltage Divider (2x 1MΩ + 0.1µF Cap) -> Multiplier 2.0
      - multiply: 2.0 
    on_value:
      then:
        - lambda: |-
            id(battery_percent) = (x - 3.2) / (4.2 - 3.2) * 100.0;
            if (id(battery_percent) > 100) id(battery_percent) = 100;
            if (id(battery_percent) < 0) id(battery_percent) = 0;
            
            // Check for low battery and show warning if device is awake
            if (id(battery_percent) < 20.0 && id(is_awake)) {
              ESP_LOGD("battery", "Low battery detected (%.1f%%), showing warning", id(battery_percent));
              id(show_low_battery_warning) = true;
              id(my_display).update();
            }
            
            id(my_display).update();
        - script.execute: clear_battery_warning

deep_sleep:
  id: sleep_module
  sleep_duration: 1d
  wakeup_pin:
    number: GPIO4
    inverted: true
    mode: INPUT_PULLUP
    allow_other_uses: true

display:
  - platform: ssd1306_i2c
    model: "SH1106 128x64"
    address: 0x3C
    id: my_display
    i2c_id: bus_a
    update_interval: 0.1s
    lambda: |-
      // Apply rotation for Left Hand Mode
      if (id(left_hand_mode)) {
        it.set_rotation(display::DISPLAY_ROTATION_180_DEGREES);
      } else {
        it.set_rotation(display::DISPLAY_ROTATION_0_DEGREES);
      }

      // Draw Interface
      
      // 00. LOW BATTERY WARNING (highest priority)
      if (id(show_low_battery_warning) && id(battery_percent) < 20.0) {
        it.fill(COLOR_OFF);
        it.print(64, 10, id(font_medium), TextAlign::TOP_CENTER, "LOW BATTERY!");
        it.printf(64, 30, id(font_small), TextAlign::TOP_CENTER, "%.0f%%", id(battery_percent));
        it.print(64, 50, id(font_small), TextAlign::TOP_CENTER, "Please charge");
        return;
      }

      // 00S. CHECK FOR SCANNING MODE - REMOVED (Use Connecting Screen instead)
      // if (id(is_scanning)) { ... }
      
      // 00Y. CHECK OFFLINE PROMPT
      if (id(offline_prompt_active)) {
         it.fill(id(my_color_black));
         it.print(64, 15, id(font_header), TextAlign::TOP_CENTER, "CONNECTION LOST");
         it.print(64, 35, id(font_small), TextAlign::TOP_CENTER, "Click to Scan WiFi");
         it.print(64, 50, id(font_small), TextAlign::TOP_CENTER, "Rotate to Dismiss");
         return;
      }

      // 00A. CHECK FOR OTA UPDATE
      if (id(ota_active)) {
         it.fill(id(my_color_black));
         if (id(ota_progress) >= 100) {
            it.print(64, 25, id(font_header), TextAlign::CENTER, "REBOOTING...");
         } else {
            it.print(64, 20, id(font_header), TextAlign::CENTER, "UPDATING...");
            it.printf(64, 35, id(font_medium), TextAlign::CENTER, "%d%%", id(ota_progress));
            
            // Progress Bar
            int bar_w = 100;
            it.rectangle((128-bar_w)/2, 55, bar_w, 4, id(my_color_white));
            it.filled_rectangle((128-bar_w)/2, 55, (int)(bar_w * id(ota_progress) / 100.0), 4, id(my_color_white));
         }
         return;
      }
      
      // 00B. CHECK FOR SLEEP COUNTDOWN
      if (id(sleep_countdown) > 0) {
        it.fill(id(my_color_black));
        
        // Breathing effect for "SLEEPING"
        float pulse = 0;
        if (id(enable_animations_v2) == 1) pulse = sin(millis() * 0.005) * 5.0; 
        it.print(64, 4 + pulse, id(font_header), TextAlign::TOP_CENTER, "SLEEPING");
        
        it.printf(64, 34, id(font_count), TextAlign::CENTER, "%d", id(sleep_countdown));
        
        // Smooth Progress Bar
        int bar_w = 80;
        int bar_h = 4;
        int bar_x = (128 - bar_w) / 2;
        int bar_y = 54;
        
        uint32_t elapsed = millis() - id(sleep_start_ms);
        float progress = 1.0f - (elapsed / 5000.0f);
        if (progress < 0) progress = 0;
        
        it.rectangle(bar_x, bar_y, bar_w, bar_h, id(my_color_white));
        if (id(enable_animations_v2) == 1) {
            it.filled_rectangle(bar_x, bar_y, (int)(bar_w * progress), bar_h, id(my_color_white));
        } else {
            it.filled_rectangle(bar_x, bar_y, (int)(bar_w * (id(sleep_countdown)/5.0f)), bar_h, id(my_color_white));
        }
        
        return;
      }

      // 00. CHECK FOR HOTSPOT MODE (WiFi Failure)
      if (id(wifi_component).is_ap_active()) {
        it.fill(id(my_color_black));
        it.print(64, 0, id(font_header), id(my_color_white), TextAlign::TOP_CENTER, "WIFI FAILED!");
        it.print(64, 16, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Connect to Hotspot:");
        it.print(64, 28, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Harem Fallback Hotspot");
        it.print(64, 40, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Pass: 4jNJPSLAfajjdHh3");
        it.print(64, 52, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "IP: 192.168.4.1");
        return; 
      } 
      

      
      // 00C. PIN ENTRY OVERLAY & CHANGE FLOW
      if (id(guest_pin_mode)) {
          it.fill(id(my_color_black));
          it.rectangle(10, 10, 108, 44, id(my_color_white));
          it.filled_rectangle(10, 10, 108, 14, id(my_color_white));
          
          if (id(pin_change_stage) == 1) {
              it.print(64, 11, id(font_small), id(my_color_black), TextAlign::TOP_CENTER, "VERIFY OLD PIN");
          } else if (id(pin_change_stage) == 2) {
              it.print(64, 11, id(font_small), id(my_color_black), TextAlign::TOP_CENTER, "SET NEW PIN");
          } else if (id(pin_change_stage) == 3) {
              it.print(64, 11, id(font_small), id(my_color_black), TextAlign::TOP_CENTER, "CONFIRM PIN");
          } else if (id(pin_change_stage) == 4) {
              it.print(64, 11, id(font_small), id(my_color_black), TextAlign::TOP_CENTER, "SUCCESS");
          } else {
              it.print(64, 11, id(font_small), id(my_color_black), TextAlign::TOP_CENTER, "SECURITY CHECK");
          }
          
          if (id(pin_error_state)) {
             if (id(pin_change_stage) == 3)
                it.print(64, 35, id(font_medium), TextAlign::CENTER, "NO MATCH");
             else
                it.print(64, 35, id(font_medium), TextAlign::CENTER, "WRONG!");
          } else {
             if (id(pin_change_stage) == 4)
                it.print(64, 35, id(font_medium), TextAlign::CENTER, "PIN SAVED");
             else
                it.printf(64, 35, id(font_medium), TextAlign::CENTER, "%02d", id(input_pin));
          }
          
          it.print(64, 63, id(font_small), TextAlign::BOTTOM_CENTER, "Rotate & Click");
          return;
      }

      // 00D. CONTROL MODE INDICATOR
      if (id(control_mode)) {
          it.print(120, 0, id(font_small), TextAlign::TOP_RIGHT, "LOCK");
      }
      
      // 0A. CHECK SETTINGS MODE (Local)
      if (id(settings_mode)) {
         it.fill(id(my_color_black));
         it.filled_rectangle(0, 0, 128, 64, id(my_color_black)); // Ensure clear
         
         it.print(64, 0, id(font_small), TextAlign::TOP_CENTER, "- SETTINGS -");
         
         // Draw WiFi Signal in top left
         it.printf(0, 0, id(font_small), TextAlign::TOP_LEFT, "%.0fdB", id(wifi_signal_sensor).state);
         
         // Draw Battery % in top right
         it.printf(127, 0, id(font_small), TextAlign::TOP_RIGHT, "%.0f%%", id(battery_percent));
         
         int y_base = 20;
         
         for (int i = 0; i < 3; i++) {
              int current_item = (id(settings_index) - 1 + i + 10) % 10;
              int y_pos = y_base + (i * 15);
              
              // Draw Caret
              auto current_font = (id(settings_index) == current_item) ? id(font_header) : id(font_small);

              if (id(settings_index) == current_item) 
                  it.print(0, y_pos, current_font, TextAlign::TOP_LEFT, ">");
                  
              // Draw Item Content
              if (current_item == 0) { // Brightness
                  if (id(edit_mode) && id(settings_index) == 0)
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Bright: [%d%%]", id(screen_brightness));
                  else
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Bright: %d%%", id(screen_brightness));
              }
              else if (current_item == 1) { // Standby
                   if (id(edit_mode) && id(settings_index) == 1)
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Standby in: [%ds]", id(standby_duration_v2));
                   else
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Standby in: %ds", id(standby_duration_v2));
              }
              else if (current_item == 2) { // Sleep
                   if (id(edit_mode) && id(settings_index) == 2)
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Sleep in: [%ds]", id(sleep_timeout_v2));
                   else
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Sleep in: %ds", id(sleep_timeout_v2));
              }
              else if (current_item == 3) { // Animations
                   if (id(edit_mode) && id(settings_index) == 3)
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Anim: [%s]", (id(enable_animations_v2) == 1) ? "ON" : "OFF");
                   else
                      it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Anim: %s", (id(enable_animations_v2) == 1) ? "ON" : "OFF");
              }
              else if (current_item == 4) { // Guest Mode
                   it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Guest: %s", id(guest_mode_state).state ? "ON" : "OFF");
              }
              else if (current_item == 5) { // Left Hand Mode
                   it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Left Hand: %s", id(left_hand_mode) ? "ON" : "OFF");
              }
              else if (current_item == 6) { // Change PIN
                  it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "Change PIN >");
              }
              else if (current_item == 7) { // WiFi
                  if (id(wifi_ssid).has_state() && id(wifi_ssid).state.length() > 0)
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "WiFi: %s", id(wifi_ssid).state.c_str());
                  else
                     it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "WiFi: Scanning...");
              }
              else if (current_item == 8) { // IP
                  if (id(wifi_ip).has_state())
                     it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "IP: %s", id(wifi_ip).state.c_str());
                  else
                     it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "IP: N/A");
              }
              else if (current_item == 9) { // Exit
                  it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "Exit");
              }
         }
         return;
      }
      
      // 0B. CHECK OVERLAY (Feedback Screen)
      if (id(local_overlay_msg) != "") {
         it.fill(id(my_color_black));
         it.print(64, 32, id(font_header), TextAlign::CENTER, id(local_overlay_msg).c_str());
         return;
      }

      if (id(remote_overlay).has_state() && id(remote_overlay).state != "") {
         std::string text = id(remote_overlay).state;
         // HACK: If we are NOT in control mode, but the overlay is a "Control Mode" feedback
         // (starts with "Bright" or "Vol"), ignore it to prevent it from sticking.
         bool is_stale_feedback = (!id(control_mode) && (text.find("Bright") == 0 || text.find("Vol") == 0));
         
         if (!is_stale_feedback) {
             it.fill(id(my_color_black));
             
             // Breathing pulse REMOVED
             // float pulse = 0;
             // if (id(enable_animations_v2) == 1) pulse = sin(millis() * 0.008) * 3.0;
             
             if (text.find("MAX") != std::string::npos || text.find("MIN") != std::string::npos) {
                it.print(64, 25, id(font_medium), TextAlign::TOP_CENTER, text.c_str());
             } else {
                it.print(64, 25, id(font_header), TextAlign::TOP_CENTER, text.c_str());
             }
             
             // Draw Progress Bar REMOVED
             // if (id(remote_line_5).has_state() && id(remote_line_5).state != "") { ... }

             // ANIMATED BAR REMOVED
             
             return;
         }
      }

      // Draw Interface - 5 Lines
      if (id(remote_line_1).has_state()) it.printf(64, 6, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_1).state.c_str());
      if (id(remote_line_2).has_state()) it.printf(64, 17, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_2).state.c_str());

      if (id(remote_line_3).state != "") {
        int x1, y1, width, height;
        std::string status_text = id(remote_line_3_status).state;
        
        // Strip '*' marker if present so user doesn't see it
        size_t star_pos = status_text.find(" *");
        if (star_pos != std::string::npos) {
            status_text = status_text.substr(0, star_pos);
        }
        
        int status_width = 0;
        if (status_text != "") {
           it.get_text_bounds(0, 0, status_text.c_str(), id(font_small), TextAlign::TOP_LEFT, &x1, &y1, &status_width, &height);
           status_width += 4;
        }
        int max_name_width = 128 - status_width;
        std::string name_text = id(remote_line_3).state;
        int name_width = 0;
        it.get_text_bounds(0, 0, name_text.c_str(), id(font_header), TextAlign::TOP_LEFT, &x1, &y1, &name_width, &height);
        
        if (name_width <= max_name_width) {
             it.print(max_name_width / 2, 28, id(font_header), id(my_color_white), TextAlign::TOP_CENTER, name_text.c_str());
        } else {
             int limit = name_width - max_name_width + 30;
             int step = (millis() / 50) % limit;
             int x_offset = (step > (name_width - max_name_width)) ? (name_width - max_name_width) : step;
             it.print(0 - x_offset, 28, id(font_header), id(my_color_white), TextAlign::TOP_LEFT, name_text.c_str());
        }
        if (status_text != "") {
           it.filled_rectangle(128 - status_width, 28, status_width, 14, id(my_color_black));
           it.print(128, 29, id(font_small), id(my_color_white), TextAlign::TOP_RIGHT, status_text.c_str());
        }
      } else {
        if (millis() < 3000) {
          it.print(64, 0, id(font_header), TextAlign::TOP_CENTER, "HARem");
          it.print(64, 25, id(font_small), TextAlign::TOP_CENTER, "HomeAssistant Remote");
          it.print(64, 40, id(font_small), TextAlign::TOP_CENTER, "Controller");
          it.print(64, 52, id(font_small), TextAlign::TOP_CENTER, "${fw_version}");
        } else {
          it.fill(id(my_color_black));
          float pulse = 0;
          if (id(enable_animations_v2) == 1) pulse = sin(millis() * 0.005) * 2.0;
          it.print(64, 15 + pulse, id(font_header), TextAlign::TOP_CENTER, "CONNECTING");
          int container_w = 100;
          int bar_w = 30;
          int start_x = (128 - container_w) / 2;
          if (id(enable_animations_v2) == 1) {
             int t = (millis() / 8) % 200;
             int pos = (t > 100) ? (200 - t) : t;
             int x_bar = start_x + (int)(pos * (container_w - bar_w) / 100.0f);
             it.rectangle(start_x, 40, container_w, 3, id(my_color_white));
             it.filled_rectangle(x_bar, 40, bar_w, 3, id(my_color_white));
          } else {
             it.rectangle(start_x, 40, container_w, 3, id(my_color_white));
             it.filled_rectangle(start_x + (container_w - bar_w)/2, 40, bar_w, 3, id(my_color_white));
          }
        }
      }

      if (id(remote_line_4).has_state()) it.printf(64, 41, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_4).state.c_str());
      if (id(remote_line_5).has_state()) it.printf(64, 52, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_5).state.c_str());

interval:
  - interval: 60s
    then:
      - script.execute: wifi_roaming_check

  - interval: 1s
    then:
      - lambda: |-
          if (id(pending_response) && (millis() - id(last_action_ms) > 5000)) {
              if (millis() - id(last_wifi_switch_ms) < 45000) {
                 id(pending_response) = false;
                 return;
              }
              ESP_LOGW("watchdog", "Response timeout! Warning only.");
              id(pending_response) = false;
              // id(offline_prompt_active) = true; // DISABLED
              id(my_display).update();
          }

script:
  - id: wifi_roaming_check
    then:
      - if:
          condition:
            lambda: |-
              if (!id(is_awake)) return false;
              // Only consider roaming if signal is weak
              if (id(wifi_signal_sensor).state > -75.0) return false;
              // Cooldown: 2 minutes (120000 ms)
              if ((millis() - id(last_wifi_switch_ms)) < 120000) return false;
              return true;
          then:
            - logger.log:
                format: "WiFi signal weak (%.1f dB), rebooting WiFi to find better signal..."
                args: [ 'id(wifi_signal_sensor).state' ]
            - lambda: |-
                id(last_wifi_switch_ms) = millis();
            - wifi.disable:
            - delay: 1s
            - wifi.enable:

  - id: wifi_manual_reconnect
    then:
      - logger.log: "Manual WiFi reconnect triggered by user."
      - lambda: |-
          id(last_wifi_switch_ms) = millis();
          id(is_scanning) = true;
          id(settings_mode) = false; // Exit settings menu
          id(edit_mode) = false;
          id(offline_prompt_active) = false; // Clear any existing offline prompt
          id(local_overlay_msg) = "";      // Clear any local overlay
          // Clear all remote lines to ensure clean "Connecting" screen
          id(remote_line_1).publish_state("");
          id(remote_line_2).publish_state("");
          id(remote_line_3).publish_state("");
          id(remote_line_4).publish_state("");
          id(remote_line_5).publish_state("");
          id(my_display).update();
      - wifi.disable:
      - delay: 1s
      - wifi.enable:
      - wait_until:
          condition:
            wifi.connected:
          timeout: 45s
      - if:
          condition:
            wifi.connected:
          then:
             - logger.log: "WiFi Connected! Returning to Connecting screen..."
             - lambda: 'id(is_scanning) = false; id(pending_response) = false; id(my_display).update();'
          else:
             - logger.log: "WiFi Scan Timed Out!"
             - lambda: 'id(is_scanning) = false; id(pending_response) = false; id(my_display).update();'
             # Fallback to AP is handled by wifi component settings or manual toggle if needed

  - id: clear_battery_warning
    mode: restart
    then:
      - delay: 3s
      - lambda: |-
          id(show_low_battery_warning) = false;
          id(my_display).update();
  - id: idle_timer
    mode: restart
    then:
      - lambda: 'id(my_display).turn_on(); id(is_awake) = true; id(sleep_countdown) = -1;'
      - delay: !lambda 'return id(standby_duration_v2) * 1000;'
      - lambda: 'id(my_display).turn_off(); id(is_awake) = false;'
      - delay: !lambda |-
          // Wait for sleep timeout before deep sleep logic
          return id(sleep_timeout_v2) * 1000;
      - lambda: 'id(sleep_countdown) = 5; id(sleep_start_ms) = millis(); id(my_display).turn_on(); id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 4; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 3; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 2; id(my_display).update();'
      - delay: 1s
      - lambda: 'id(sleep_countdown) = 1; id(my_display).update();'
      - delay: 1s
      - lambda: |-
          id(sleep_countdown) = -1;
          id(my_display).turn_off();
      - lambda: |-
          id(sleep_countdown) = -1;
          id(my_display).turn_off();
          id(oled_power).turn_off();
          // Lock OLED Power Pin LOW during Deep Sleep (ONLY GPIO1)
          gpio_hold_en(GPIO_NUM_1);
      - logger.log: "Entering Deep Sleep..."
      - deep_sleep.enter: sleep_module

  - id: send_click_event
    mode: restart
    then:
      - script.execute: idle_timer
      - logger.log: "SUCCESS: Click Sent to HA"
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: click

  - id: send_toggle_guest_event
    mode: restart
    then:
      - script.execute: idle_timer
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: toggle_guest

  - id: send_back_event
    mode: restart
    then:
      - script.execute: idle_timer
      - logger.log: "SUCCESS: Back Sent to HA"
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: back

  - id: send_rotate_cw_hold_event
    mode: restart
    then:
      - script.execute: idle_timer
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: rotate_cw_hold

  - id: send_rotate_ccw_hold_event
    mode: restart
    then:
      - script.execute: idle_timer
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: rotate_ccw_hold

  - id: send_clear_overlay_event
    mode: restart
    then:
      - delay: 100ms
      - script.execute: idle_timer
      - homeassistant.event:
          event: esphome.remote_action
          data:
            action: clear_overlay

  - id: show_local_warning
    mode: restart
    then:
      - lambda: 'id(local_overlay_msg) = "Not Supported !"; id(my_display).update();'
      - delay: 1.5s
      - lambda: 'id(local_overlay_msg) = ""; id(my_display).update();'

  - id: handle_settings_hold
    then:
      - delay: 4s
      - lambda: |-
          id(processed_settings_hold) = true;
          id(settings_mode) = !id(settings_mode);
          ESP_LOGD("main", "Auto-Settings Hold: settings_mode is now %s", id(settings_mode) ? "ON" : "OFF");
          id(edit_mode) = false;
          id(settings_index) = 0;
          id(my_display).turn_on();
          id(is_awake) = true;

  - id: pin_success_sequence
    then:
      - delay: 1.5s
      - lambda: |-
          id(guest_pin_mode) = false;
          id(pin_change_stage) = 0;
          id(settings_mode) = false;
          id(my_display).update();

switch:
  - platform: gpio
    pin: 
      number: GPIO1
      drive_strength: 40mA
    id: oled_power
    restore_mode: ALWAYS_ON
    name: "OLED Power"
    internal: true
