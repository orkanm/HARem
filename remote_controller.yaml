substitutions:
  name: "ha-remote"
  friendly_name: "HA Remote Controller"
  fw_version: "v0.1"

esphome:
  name: harem
  friendly_name: HARem
  on_boot:
    priority: 600
    then:
      - script.execute: idle_timer
      - lambda: 'id(my_display).set_contrast(id(screen_brightness) / 100.0);'

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: !secret harem_api_key

ota:
  - platform: esphome
    password: !secret harem_ota_password

wifi:
  id: wifi_component
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password

    - ssid: !secret 2_wifi_ssid
      password: !secret 2_wifi_password

    - ssid: !secret 3_wifi_ssid
      password: !secret 3_wifi_password
    # Set a low power save mode to speed up the connection when waking up
  power_save_mode: LIGHT
  
  # Callback when Wi-Fi disconnects
  on_disconnect:
    - logger.log: "Wi-Fi disconnected!"
    - delay: 180s   # wait 3 minutes
    - if:
        condition:
          wifi.connected:
        then:
          - logger.log: "Wi-Fi reconnected within 3 minutes."
        else:
          - logger.log: "Wi-Fi still down, rebooting..."



  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Harem Fallback Hotspot"
    password: !secret harem_ap_password

captive_portal:

# Colors
color:
  - id: my_color_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_color_black
    red: 0%
    green: 0%
    blue: 0%

# I2C Configuration for OLED
i2c:
  sda: GPIO5
  scl: GPIO6
  scan: true
  id: bus_a

# Font configuration
font:
  - file: "gfonts://Roboto"
    id: font_main
    size: 14
  - file: "gfonts://Material Icons"
    id: font_icon
    size: 24
    glyphs:
      - "\U0000E0F0" # lightbulb (was mdi-lightbulb-on)
      - "\U0000E8AC" # power_settings_new (was mdi-power-plug? using generic power for now)
      - "\U0000E335" # power_off (was mdi-lightbulb-off? using close/off)
      - "\U0000E02C" # movie
      - "\U0000E63C" # power (plug)
  - file: "gfonts://Roboto"
    id: font_header
    size: 12
  - file: "gfonts://Roboto"
    id: font_small
    size: 10



# Globals to track state
globals:
  - id: is_awake
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: standby_duration
    type: int
    restore_value: yes
    initial_value: '60'
  - id: screen_brightness
    type: int
    restore_value: yes
    initial_value: '100'
  - id: settings_mode
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: settings_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: edit_mode
    type: bool
    restore_value: no
    initial_value: 'false'

# Import Home Assistant Entities
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO7
      mode: INPUT_PULLUP
      inverted: true
    name: "Encoder Button"
    id: encoder_button
    on_click:
      - min_length: 10ms
        max_length: 300ms
        then:
          - if:
              condition:
                lambda: 'return id(settings_mode);'
              then:
                # SETTINGS MODE CLICK
                - script.execute: idle_timer
                - if:
                    condition:
                      # Exit is now index 4
                      lambda: 'return id(settings_index) == 4;'
                    then:
                      - globals.set:
                          id: settings_mode
                          value: 'false'
                      - globals.set:
                          id: edit_mode
                          value: 'false'
                    else:
                      # Only toggle edit mode for index 0 (Brightness) and 1 (Standby)
                      - if:
                          condition:
                             lambda: 'return id(settings_index) < 2;'
                          then:
                             - lambda: 'id(edit_mode) = !id(edit_mode);'
                      # Save to flash immediately on exit edit? ESPHome does this periodically or on shutdown usually.
                      # We can force save if critical, but standard restore_value handles it.

              else:
                # NORMAL MODE CLICK
                - if:
                    condition:
                      lambda: 'return id(is_awake);'
                    then:
                      - script.execute: idle_timer
                      - logger.log: "Short Click Detected!"
                      - homeassistant.event:
                          event: esphome.remote_action
                          data:
                            action: click
                    else:
                      # WAKE UP
                      - script.execute: idle_timer
                      - logger.log: "Waking up from sleep"

      - min_length: 301ms
        max_length: 1500ms
        then:
          - if:
              condition:
                lambda: 'return !id(settings_mode);'
              then:
                - logger.log: "Back Action Detected!"
                - homeassistant.event:
                    event: esphome.remote_action
                    data:
                      action: back

      - min_length: 1501ms
        max_length: 10s
        then:
          - logger.log: "Toggle Settings Mode"
          - lambda: |-
               id(settings_mode) = !id(settings_mode);
               id(edit_mode) = false;
               id(settings_index) = 0;
               id(my_display).turn_on();
               id(is_awake) = true;

  # Status sensors removed - Managed by Home Assistant text
    
text_sensor:
  - platform: homeassistant
    id: remote_line_1
    entity_id: input_text.harem_line_1
  - platform: homeassistant
    id: remote_line_2
    entity_id: input_text.harem_line_2
  - platform: homeassistant
    id: remote_line_3
    entity_id: input_text.harem_line_3
  - platform: homeassistant
    id: remote_line_4
    entity_id: input_text.harem_line_4
  - platform: homeassistant
    id: remote_line_5
    entity_id: input_text.harem_line_5

  - platform: homeassistant
    id: remote_line_3_status
    entity_id: input_text.harem_line_3_status
  - platform: homeassistant
    id: remote_overlay
    entity_id: input_text.harem_overlay

  - platform: wifi_info
    ip_address:
      id: wifi_ip
    ssid:
      id: wifi_ssid

sensor:
  - platform: rotary_encoder
    id: encoder
    pin_a:
      number: GPIO8
      mode: INPUT_PULLUP
    pin_b:
      number: GPIO9
      mode: INPUT_PULLUP
    resolution: 1
    on_clockwise:
      - script.execute: idle_timer
      - if:
          condition: 
            lambda: 'return id(settings_mode);'
          then:
            - if:
                condition:
                  lambda: 'return id(edit_mode);'
                then:
                  # Adjust Value (+)
                   - lambda: |-
                       bool changed = false;
                       if (id(settings_index) == 0) { // Brightness
                          if (id(screen_brightness) < 100) {
                              id(screen_brightness) += 10;
                              id(my_display).set_contrast(id(screen_brightness) / 100.0);
                              changed = true;
                          }
                       } else if (id(settings_index) == 1) { // Standby
                          if (id(standby_duration) < 300) {
                              id(standby_duration) += 10;
                              changed = true;
                          }
                       }
                       if (changed) id(my_display).update();
                else:
                  # Move Down
                  - lambda: |-
                      // Max index 4 (0:Bright, 1:Standby, 2:WiFi, 3:IP, 4:Exit)
                      if (id(settings_index) < 4) {
                          id(settings_index)++;
                          id(my_display).update();
                      }
          else:
            - homeassistant.event:
                event: esphome.remote_action
                data:
                  action: next
            # Removed unconditional update to prevent lag during rapid rotation

    on_anticlockwise:
      - script.execute: idle_timer
      - if:
          condition: 
            lambda: 'return id(settings_mode);'
          then:
             - if:
                condition:
                  lambda: 'return id(edit_mode);'
                then:
                  # Adjust Value (-)
                   - lambda: |-
                       bool changed = false;
                       if (id(settings_index) == 0) { // Brightness
                          if (id(screen_brightness) > 10) {
                              id(screen_brightness) -= 10;
                              id(my_display).set_contrast(id(screen_brightness) / 100.0);
                              changed = true;
                          }
                       } else if (id(settings_index) == 1) { // Standby
                          if (id(standby_duration) > 10) {
                              id(standby_duration) -= 10;
                              changed = true;
                          }
                       }
                       if (changed) id(my_display).update();
                else:
                  # Move Up
                  - lambda: |-
                      if (id(settings_index) > 0) {
                          id(settings_index)--;
                          id(my_display).update();
                      }
          else:
            - homeassistant.event:
                event: esphome.remote_action
                data:
                  action: prev
            # Removed unconditional update

  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_sensor
    update_interval: 60s




display:
  - platform: ssd1306_i2c
    model: "SH1106 128x64"
    address: 0x3C
    id: my_display
    i2c_id: bus_a
    update_interval: 0.1s
    lambda: |-
      // Draw Interface
      
      // 00. CHECK FOR HOTSPOT MODE (WiFi Failure)
      if (id(wifi_component).is_ap_active()) {
        it.fill(id(my_color_black));
        it.print(64, 0, id(font_header), id(my_color_white), TextAlign::TOP_CENTER, "WIFI FAILED!");
        it.print(64, 16, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Connect to Hotspot:");
        it.print(64, 28, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Harem Fallback Hotspot");
        it.print(64, 40, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "Pass: 12345678");
        it.print(64, 52, id(font_small), id(my_color_white), TextAlign::TOP_CENTER, "IP: 192.168.4.1");
        return; 
      }
      
      // 0A. CHECK SETTINGS MODE (Local)
      if (id(settings_mode)) {
         it.fill(id(my_color_black));
         it.filled_rectangle(0, 0, 128, 64, id(my_color_black)); // Ensure clear
         
         it.print(64, 0, id(font_small), TextAlign::TOP_CENTER, "- SETTINGS -");
         
         int y_base = 20;
         int row_h = 10; // Tighter spacing for more info? No, keep generic 15 but scroll.
         
         // Menu Items:
         // 0: Brightness
         // 1: Standby
         // 2: WiFi: [SSID]
         // 3: IP: [IP]
         // 4: Exit
         
         // Draw 3 rows centered around selection
         int start_idx = id(settings_index) - 1;
         
         for (int i = 0; i < 3; i++) {
             int current_item = start_idx + i;
             int y_pos = y_base + (i * 15);
             
             // Skip if out of bounds
             if (current_item < 0 || current_item > 4) continue;
             
             // Draw Caret
             auto current_font = (id(settings_index) == current_item) ? id(font_header) : id(font_small);

             if (id(settings_index) == current_item) 
                 it.print(0, y_pos, current_font, TextAlign::TOP_LEFT, ">");
                 
             // Draw Item Content
             if (current_item == 0) { // Brightness
                 if (id(edit_mode) && id(settings_index) == 0)
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Bright: [%d%%]", id(screen_brightness));
                 else
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Bright: %d%%", id(screen_brightness));
             }
             else if (current_item == 1) { // Standby
                 if (id(edit_mode) && id(settings_index) == 1)
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Standby: [%ds]", id(standby_duration));
                 else
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "Standby: %ds", id(standby_duration));
             }
             else if (current_item == 2) { // WiFi
                 if (id(wifi_ssid).has_state())
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "WiFi: %s", id(wifi_ssid).state.c_str());
                 else
                    it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "WiFi: Scanning...");
             }
             else if (current_item == 3) { // IP
                 if (id(wifi_ip).has_state())
                    it.printf(10, y_pos, current_font, TextAlign::TOP_LEFT, "IP: %s", id(wifi_ip).state.c_str());
                 else
                    it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "IP: N/A");
             }
             else if (current_item == 4) { // Exit
                 it.print(10, y_pos, current_font, TextAlign::TOP_LEFT, "Exit");
             }
         }
         return;
      }
      
      // 0B. CHECK OVERLAY (Feedback Screen)
      if (id(remote_overlay).has_state() && id(remote_overlay).state != "") {
         // Clear screen
         it.fill(id(my_color_black));
         
         // Draw Box
         it.filled_rectangle(0, 0, 128, 64, id(my_color_black));
         
         // Draw Text Centered
         it.print(64, 25, id(font_header), TextAlign::TOP_CENTER, id(remote_overlay).state.c_str());
         
         // Draw spinner/dots? (Optional, let's keep it simple first)
         return; // Skip drawing the rest
      }

      // Draw Interface - 5 Lines
      
      // Line 1 (Index - 2) - y=6 (Safe from Top Bezel)
      if (id(remote_line_1).has_state()) {
        it.printf(64, 6, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_1).state.c_str());
      }
      
      // Line 2 (Index - 1) - y=17
      if (id(remote_line_2).has_state()) {
        it.printf(64, 17, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_2).state.c_str());
      }

      // Line 3 (Selected) - Split Layout: Name (Scrolls) + Status (Fixed)
      if (id(remote_line_3).state != "") {
        int x1, y1, width, height;
        std::string status_text = id(remote_line_3_status).state;
        int status_width = 0;
        
        // 1. Calculate Status Width
        if (status_text != "") {
           it.get_text_bounds(0, 0, status_text.c_str(), id(font_small), TextAlign::TOP_LEFT, &x1, &y1, &status_width, &height);
           status_width += 4; // Add padding
        }

        int max_name_width = 128 - status_width;
        
        // 2. Draw Name (Scrolling logic using max_name_width)
        std::string name_text = id(remote_line_3).state;
        int name_width = 0;
        it.get_text_bounds(0, 0, name_text.c_str(), id(font_header), TextAlign::TOP_LEFT, &x1, &y1, &name_width, &height);
        
        if (name_width <= max_name_width) {
             // Fits in available space - Center it
             it.print(max_name_width / 2, 28, id(font_header), TextAlign::TOP_CENTER, name_text.c_str());
        } else {
             // Too long - Scroll it
             // Let's force it to be 0 if it fits, else calculate.
             int limit = name_width - max_name_width + 30; // 30px pause
             int step = (millis() / 50) % limit;
             int x_offset = (step > (name_width - max_name_width)) ? (name_width - max_name_width) : step;
             
             it.print(0 - x_offset, 28, id(font_header), TextAlign::TOP_LEFT, name_text.c_str());
        }

        // 3. Draw Status (Fixed Right)
        if (status_text != "") {
           // Clear background for status
           it.filled_rectangle(128 - status_width, 28, status_width, 14, id(my_color_black));
           it.print(128, 29, id(font_small), TextAlign::TOP_RIGHT, status_text.c_str());
        }
      } else {
        if (millis() < 3000) {
          // Splash Screen (First 3.0s)
          it.print(64, 0, id(font_header), TextAlign::TOP_CENTER, "HARem");
          it.print(64, 25, id(font_small), TextAlign::TOP_CENTER, "HomeAssistant Remote");
          it.print(64, 40, id(font_small), TextAlign::TOP_CENTER, "Controller");
        } else {
          // Waiting Screen (After 3.0s)
          it.print(64, 20, id(font_header), TextAlign::TOP_CENTER, "Waiting...");
          it.print(64, 50, id(font_small), TextAlign::TOP_CENTER, "${fw_version}");
        }
      }

      // Line 4 (Index + 1) - y=41
      if (id(remote_line_4).has_state()) {
        it.printf(64, 41, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_4).state.c_str());
      }

      // Line 5 (Index + 2) - y=52 (Safe from Bottom Bezel)
      if (id(remote_line_5).has_state()) {
        it.printf(64, 52, id(font_small), TextAlign::TOP_CENTER, "%s", id(remote_line_5).state.c_str());
      }



# Script removed - Logic moved to Home Assistant

script:
  - id: idle_timer
    mode: restart
    then:
      - lambda: 'id(my_display).turn_on(); id(is_awake) = true;'
      - delay: !lambda 'return id(standby_duration) * 1000;'
      - lambda: 'id(my_display).turn_off(); id(is_awake) = false;'
